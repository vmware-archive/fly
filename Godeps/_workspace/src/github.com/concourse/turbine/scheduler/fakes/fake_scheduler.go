// This file was generated by counterfeiter
package fakes

import (
	"github.com/cloudfoundry-incubator/garden/warden"
	"github.com/concourse/turbine/api/builds"
	"github.com/concourse/turbine/builder"
	"github.com/concourse/turbine/scheduler"

	"sync"
)

type FakeScheduler struct {
	StartStub        func(builds.Build)
	startMutex       sync.RWMutex
	startArgsForCall []struct {
		arg1 builds.Build
	}
	AttachStub        func(builder.RunningBuild)
	attachMutex       sync.RWMutex
	attachArgsForCall []struct {
		arg1 builder.RunningBuild
	}
	AbortStub        func(guid string)
	abortMutex       sync.RWMutex
	abortArgsForCall []struct {
		guid string
	}
	HijackStub        func(guid string, process warden.ProcessSpec, io warden.ProcessIO) (warden.Process, error)
	hijackMutex       sync.RWMutex
	hijackArgsForCall []struct {
		guid    string
		process warden.ProcessSpec
		io      warden.ProcessIO
	}
	hijackReturns struct {
		result1 warden.Process
		result2 error
	}
	DrainStub        func() []builder.RunningBuild
	drainMutex       sync.RWMutex
	drainArgsForCall []struct{}
	drainReturns struct {
		result1 []builder.RunningBuild
	}
}

func (fake *FakeScheduler) Start(arg1 builds.Build) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
		arg1 builds.Build
	}{arg1})
	if fake.StartStub != nil {
		fake.StartStub(arg1)
	}
}

func (fake *FakeScheduler) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeScheduler) StartArgsForCall(i int) builds.Build {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return fake.startArgsForCall[i].arg1
}

func (fake *FakeScheduler) Attach(arg1 builder.RunningBuild) {
	fake.attachMutex.Lock()
	defer fake.attachMutex.Unlock()
	fake.attachArgsForCall = append(fake.attachArgsForCall, struct {
		arg1 builder.RunningBuild
	}{arg1})
	if fake.AttachStub != nil {
		fake.AttachStub(arg1)
	}
}

func (fake *FakeScheduler) AttachCallCount() int {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return len(fake.attachArgsForCall)
}

func (fake *FakeScheduler) AttachArgsForCall(i int) builder.RunningBuild {
	fake.attachMutex.RLock()
	defer fake.attachMutex.RUnlock()
	return fake.attachArgsForCall[i].arg1
}

func (fake *FakeScheduler) Abort(guid string) {
	fake.abortMutex.Lock()
	defer fake.abortMutex.Unlock()
	fake.abortArgsForCall = append(fake.abortArgsForCall, struct {
		guid string
	}{guid})
	if fake.AbortStub != nil {
		fake.AbortStub(guid)
	}
}

func (fake *FakeScheduler) AbortCallCount() int {
	fake.abortMutex.RLock()
	defer fake.abortMutex.RUnlock()
	return len(fake.abortArgsForCall)
}

func (fake *FakeScheduler) AbortArgsForCall(i int) string {
	fake.abortMutex.RLock()
	defer fake.abortMutex.RUnlock()
	return fake.abortArgsForCall[i].guid
}

func (fake *FakeScheduler) Hijack(guid string, process warden.ProcessSpec, io warden.ProcessIO) (warden.Process, error) {
	fake.hijackMutex.Lock()
	defer fake.hijackMutex.Unlock()
	fake.hijackArgsForCall = append(fake.hijackArgsForCall, struct {
		guid    string
		process warden.ProcessSpec
		io      warden.ProcessIO
	}{guid, process, io})
	if fake.HijackStub != nil {
		return fake.HijackStub(guid, process, io)
	} else {
		return fake.hijackReturns.result1, fake.hijackReturns.result2
	}
}

func (fake *FakeScheduler) HijackCallCount() int {
	fake.hijackMutex.RLock()
	defer fake.hijackMutex.RUnlock()
	return len(fake.hijackArgsForCall)
}

func (fake *FakeScheduler) HijackArgsForCall(i int) (string, warden.ProcessSpec, warden.ProcessIO) {
	fake.hijackMutex.RLock()
	defer fake.hijackMutex.RUnlock()
	return fake.hijackArgsForCall[i].guid, fake.hijackArgsForCall[i].process, fake.hijackArgsForCall[i].io
}

func (fake *FakeScheduler) HijackReturns(result1 warden.Process, result2 error) {
	fake.HijackStub = nil
	fake.hijackReturns = struct {
		result1 warden.Process
		result2 error
	}{result1, result2}
}

func (fake *FakeScheduler) Drain() []builder.RunningBuild {
	fake.drainMutex.Lock()
	defer fake.drainMutex.Unlock()
	fake.drainArgsForCall = append(fake.drainArgsForCall, struct{}{})
	if fake.DrainStub != nil {
		return fake.DrainStub()
	} else {
		return fake.drainReturns.result1
	}
}

func (fake *FakeScheduler) DrainCallCount() int {
	fake.drainMutex.RLock()
	defer fake.drainMutex.RUnlock()
	return len(fake.drainArgsForCall)
}

func (fake *FakeScheduler) DrainReturns(result1 []builder.RunningBuild) {
	fake.DrainStub = nil
	fake.drainReturns = struct {
		result1 []builder.RunningBuild
	}{result1}
}

var _ scheduler.Scheduler = new(FakeScheduler)
